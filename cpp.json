{
	"power with no mod": {
		"prefix": "qpow",
		"body": [
			"int qpow(int x, int y) {",
			"\tint ans = 1;",
			"\tfor (; y; y >>= 1, x *= x) if (y & 1) ans *= x;",
			"\treturn ans;",
			"}"
		],
		"description": "Power with no P"
	},
	"power with mod": {
		"prefix": "qpow",
		"body": [
			"int qpow(int x, int y, int P) {",
			"\tint ans = 1;",
			"\tfor (; y; y >>= 1, x = 1ll * x * x % P)",
			"\t\tif (y & 1) ans = 1ll * ans * x % P;",
			"\treturn ans % P;",
			"}"
		]
	},
	"Read but int": {
		"prefix": "read",
		"body": [
			"template<typename DataType>",
			"DataType read() {",
			"\tDataType t = 0, f = 0;",
			"\tchar ch = getchar();",
			"\tfor (; !isdigit(ch); ch = getchar()) f ^= (ch == '-');",
			"\tfor (; isdigit(ch); ch = getchar()) t = (t << 1) + (t << 3) + (ch ^ 48);",
			"\treturn f ? ~t + 1 : t;",
			"}"
		]
	},
	"Read but void": {
		"prefix": "read",
		"body": [
			"template<typename T>",
			"void read(T &x) {",
			"\tx = 0; bool f = false; char ch = getchar();",
			"\tfor (; !isdigit(ch); ch = getchar()) f ^= (ch == '-');",
			"\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);",
			"\tx = f ? ~x + 1 : x;",
			"}",
			"template<typename T, typename ...Args>",
			"void read(T &x, Args &...args) {read(x); read(args...);}"
		]
	},
	"get phi" : {
		"prefix" : "phi",
		"body" : [
			"int phi(int x) {",
			"\tint ans = x;",
			"\tfor (int i = 2; i * i <= x; ++i) {",
			"\t\tif (x % i) continue;",
			"\t\tans = ans / i * (i - 1);",
			"\t\twhile (!(x % i)) x /= i;",
			"\t} if (x > 1) ans = ans / x * (x - 1);",
			"\treturn ans;",
			"}"
		]
	},
	"quick mul": {
		"prefix": "mul",
		"body": [
			"int mul(int x, int y, int P) {return (x * y - (long long)((long double) x / P * y) * P + P) % P;}"
		]
	},
	"IO" : {
		"prefix" : "IO",
		"body" : [
			"namespace IO {",
			"\tconst int precision = 5;",
			"\ttemplate<typename T>",
			"\tinline T read() {",
			"\t\tT x = 0; bool f = false; char ch = getchar();",
			"\t\tfor (; !isdigit(ch); ch = getchar()) f ^= (ch == '-');",
			"\t\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);",
			"\t\treturn f ? ~x + 1 : x;",
			"\t}",
			"\ttemplate<>",
			"\tinline char read() {char ch = getchar(); for (; !isgraph(ch); ch = getchar()) ; return ch;}",
			"\ttemplate<>",
			"\tinline std::string read() {",
			"\t\tstd::string str = \" \"; char ch = getchar();",
			"\t\tfor (; !isgraph(ch); ch = getchar());",
			"\t\tfor (; isgraph(ch); ch = getchar()) str += ch;",
			"\t\treturn str;",
			"\t}",
			"\ttemplate<>",
			"\tinline double read() {",
			"\t\tdouble x = 0.0; bool f = false; char ch = getchar();",
			"\t\tfor (; !isdigit(ch); ch = getchar()) f ^= (ch == '-');",
			"\t\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + (ch ^ 48);",
			"\t\tif (ch == '.') {double e = 1; for (; isdigit(ch); ch = getchar()) x = x + e * 0.1;}",
			"\t\treturn f ? -x : x;",
			"\t}",
			"\ttemplate<typename T>",
			"\tinline void read(T &x) {x = read<T>();}",
			"\ttemplate<typename T, typename ...Args>",
			"\tinline void read(T &x, Args &...args) {read(x); read(args...);}",
			"\tvoid write(int x) {if (x < 0) {x = ~x + 1; putchar('-');} if (x > 9) write(x / 10); putchar(x % 10 + '0');}",
			"\tvoid write(long long x) {if (x < 0) {x = ~x + 1; putchar('-');} if (x > 9) write(x / 10); putchar(x % 10 + '0');}",
			"\tvoid write(double x) {",
			"\t\tif (x == 0) {putchar('0'); putchar('.'); for (int i = 0; i < precision; ++i) putchar('0');}",
			"\t\tif (x < 0) {putchar('-'); write(-x);}",
			"\t\telse {",
			"\t\t\tdouble r = x - floor(x), l = floor(x);",
			"\t\t\tif (l == 0) putchar('0'); char buf[310]; int i = 0;",
			"\t\t\twhile (floor(l) != 0) {buf[i ++] = floor(l - floor(l / 10) * 10); l /= 10;}",
			"\t\t\tfor (int j = i - 1; j >= 0; --j) putchar(buf[j] ^ 48); putchar('.');",
			"\t\t\tfor (int i = 0; i < precision - 1; ++i) putchar(int(floor(r *= 10)) ^ 48), r -= floor(r); double tmp = r * 10;",
			"\t\t\tif (int(floor(tmp * 10 - floor(tmp) * 10)) >= 5) putchar((int(floor(tmp)) + 1) ^ 48);",
			"\t\t\telse putchar(int(floor(tmp)) ^ 48);",
			"\t\t}",
			"\t}",
			"\tvoid write(char x) {putchar(x);}",
			"\tvoid write(std::string x) {for (auto ch : x) putchar(ch);}",
			"\ttemplate<typename T>",
			"\tvoid write(T x) {write(x);}",
			"\ttemplate<typename T, typename ...Args>",
			"\tvoid write(T x, Args ...args) {write(x); write(args...);}",
			"}"
		]
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"class Matrix {",
			"\tprivate: int n, m;",
			"\tpublic: std::vector<std::vector<int>> a;",
			"\tpublic: Matrix(int n = 0, int m = 0, int p = 0): n(n), m(m) {",
			"\t\ta.resize(n, std::vector<int>(m, 0));",
			"\t\tif (p) for (int i = 0; i < n; ++i) a[i][i] = 1;",
			"\t}",
			"\tpublic: std::vector<int>& operator [] (int x) & {return a[x];}",
			"\tpublic: const std::vector<int>& operator[](int x) const& {return a[x];}",
			"\t#ifdef P",
			"\tpublic: friend Matrix operator * (const Matrix &a, const Matrix &b) {",
			"\t\tMatrix ans = Matrix(a.n, b.m);",
			"\t\tfor (int i = 0; i < a.n; ++i)",
			"\t\t\tfor (int j = 0; j < b.m; ++j)",
			"\t\t\t\tfor (int k = 0; k < a.m; ++k) ans.a[i][j] = (ans.a[i][j] + 1ll * a.a[i][k] * b.a[k][j] % P) % P;",
			"\t\treturn ans;",
			"\t}",
			"\t#else",
			"\tpublic: friend Matrix operator * (const Matrix &a, const Matrix &b) {",
			"\t\tMatrix ans = Matrix(a.n, b.m);",
			"\t\tfor (int i = 0; i < a.n; ++i)",
			"\t\t\tfor (int j = 0; j < b.m; ++j)",
			"\t\t\t\tfor (int k = 0; k < a.m; ++k) ans.a[i][j] += a.a[i][k] * b.a[k][j];",
			"\t\treturn ans;",
			"\t}",
			"\t#endif",
			"\tpublic: void print() {",
			"\t\tfor (int i = 0; i < n; ++i) {",
			"\t\t\tfor (int j = 0; j < m; ++j) {",
			"\t\t\t\t#ifdef int",
			"\t\t\t\tprintf(\"%lld%c\", a[i][j], ' ');",
			"\t\t\t\t#else",
			"\t\t\t\tprintf(\"%d%c\", a[i][j], ' ');",
			"\t\t\t\t#endif",
			"\t\t\t} puts(\"\");",
			"\t\t} return void();",
			"\t}",
			"\tpublic: void Unit() {",
			"\t\tassert(n == m);",
			"\t\tfor (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) a[i][j] = (i == j);",
			"\t\treturn void();",
			"\t}",
			"\tpublic: friend Matrix operator ^ (Matrix a, int k) {",
			"\t\tMatrix ans = Matrix(a.n, a.m, 1);",
			"\t\tfor (; k; k >>= 1, a = a * a) if (k & 1) ans = ans * a;",
			"\t\treturn ans;",
			"\t}",
			"};"
		]
	},
	"ST Table": {
		"prefix": "ST",
		"body": [
			"template<int N, int size>",
			"class St_Table {",
			"\tprivate: int f[N][size];",
			"\tpublic: void Init(int n, int *a) {",
			"\t\tfor (int i = 1; i <= n; ++i) f[i][0] = a[i];",
			"\t\tfor (int j = 1; j <= size; ++j)",
			"\t\t\tfor (int i = 1; i <= n - (1ll << j) + 1; ++i)",
			"\t\t\t\tf[i][j] = std::min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);",
			"\t\treturn void();",
			"\t}",
			"\tpublic: int Query(int l, int r) {",
			"\t\tint k = std::log2(r - l + 1);",
			"\t\treturn std::min(f[l][k], f[r - (1 << k) + 1][k]);",
			"\t}",
			"};"
		]
	},
	"FWT": {
		"prefix": "FWT",
		"body": [
			"template<int N, int P>",
			"class FastWalshHadamardTransform {",
			"\tprivate: int Cng(int x) {return (x % P + P) % P;}",
			"\tprivate: int Add(int x, int y) {x = Cng(x), y = Cng(y); return (x + y) % P;}",
			"\tprivate: int Mul(int x, int y) {x = Cng(x), y = Cng(y); return 1ll * x * y % P;}",
			"\tprivate: void Madd(int &x, int y) {x = Add(x, y);} ",
			"\tprivate: void Mmul(int &x, int y) {x = Mul(x, y);}",
			"\tpublic: int Fpow(int x, int y) {int ans = 1; for (; y; y >>= 1, Mmul(x, x)) if (y & 1) Mmul(ans, x); return ans;}",
			"\tpublic: int n, A[N], B[N], a[N], b[N];",
			"\tpublic: void Copy() {memcpy(a, A, sizeof A); memcpy(b, B, sizeof B);}",
			"\tpublic: void Mul() {for (int i = 0; i < n; ++i) Mmul(a[i], b[i]);}",
			"\tpublic: void Print() {for (int i = 0; i < n; ++i) printf(\"%d \", a[i]); puts(\"\");}",
			"\t#define for1 for (int i = 1; i < n; i <<= 1)",
			"\t#define for2 for (int p = i << 1, j = 0; j < n; j += p)",
			"\t#define for3 for (int k = 0; k < i; ++k)",
			"\tpublic: void Or(int *a, int op) {for1 for2 for3 Madd(a[i + j + k], Mul(a[j + k], op));}",
			"\tpublic: void And(int *a, int op) {for1 for2 for3 Madd(a[j + k], Mul(a[i + j + k], op));}",
			"\tpublic: void Xor(int *a, int op) {",
			"\t\tfor1 for2 for3 {",
			"\t\t\tint x = a[j + k], y = a[i + j + k];",
			"\t\t\ta[j + k] = Add(x, y), a[i + j + k] = Add(x, -y);",
			"\t\t\tMmul(a[j + k], op); Mmul(a[i + j + k], op);",
			"\t\t}",
			"\t}",
			"};",
			"FastWalshHadamardTransform<N, P> FWT;",
			"signed main() {",
			"\tscanf(\"%d\", &FWT.n); FWT.n = 1 << FWT.n; // atention",
			"\tfor (int i = 0; i < FWT.n; ++i) scanf(\"%d\", &FWT.A[i]);",
			"\tfor (int i = 0; i < FWT.n; ++i) scanf(\"%d\", &FWT.B[i]);",
			"\tFWT.Copy(); FWT.Or(FWT.a, 1); FWT.Or(FWT.b, 1); FWT.Mul(); FWT.Or(FWT.a, -1); FWT.Print();",
			"\tFWT.Copy(); FWT.And(FWT.a, 1); FWT.And(FWT.b, 1); FWT.Mul(); FWT.And(FWT.a, -1); FWT.Print();",
			"\tFWT.Copy(); FWT.Xor(FWT.a, 1); FWT.Xor(FWT.b, 1); FWT.Mul(); FWT.Xor(FWT.a, FWT.Fpow(2, P - 2)); FWT.Print();",
			"\treturn 0;",
			"}"
		]
	},
	"MODINT": {
		"prefix": "modint",
		"body": [
			"namespace modint {",
			"\tint fac[N], inv[N], finv[N];",
			"\tint Rev(int x) {return (x % P + P) % P;}",
			"\tint Add(int x, int y) {x = Rev(x), y = Rev(y); return (x + y) % P;}",
			"\ttemplate<typename ...Args>",
			"\tint Add(int x, Args ...args) {return Add(x, Add(args...));}",
			"\tvoid cAdd(int &x, int y) {x = Add(x, y);}",
			"\ttemplate<typename ...Args>",
			"\tvoid cAdd(int &x, Args ...args) {x = Add(x, args...);}",
			"\tint Mul(int x, int y) {x = Rev(x), y = Rev(y); return 1ll * x * y % P;}",
			"\ttemplate<typename ...Args>",
			"\tint Mul(int x, Args ...args) {return Mul(x, Mul(args...));}",
			"\tvoid cMul(int &x, int y) {x = Mul(x, y);}",
			"\ttemplate<typename ...Args>",
			"\tvoid cMul(int &x, Args ...args) {x = Mul(x, args...);}",
			"\tvoid Init() {",
			"\t\tfac[0] = fac[1] = inv[1] = finv[0] = finv[1] = 1;",
			"\t\tfor (int i = 2; i <= n; ++i) {",
			"\t\t\tfac[i] = Mul(fac[i - 1], i);",
			"\t\t\tinv[i] = Mul((P - P / i), inv[P % i]);",
			"\t\t\tfinv[i] = Mul(finv[i - 1], inv[i]);",
			"\t\t} return void();",
			"\t}",
			"}"
		]
	},
	"RandomSeed": {
		"prefix": "SetRand",
		"body": [
			"std::mt19937 builder(std::chrono::system_clock::now().time_since_epoch().count());",
			"std::uniform_int_distribution<int> random(Llimit, Rlimit);"
		]
	},
	"Exkmp(Z-algorithm)": {
		"prefix": "Exkmp",
		"body": [
			"class Exkmp {",
            "\tprivate: int n;",
            "\tprivate: char str[N];",
            "\tpublic: int z[N], p[N];",
            "\tpublic: auto InitZ(char *s, int n) -> void {",
            "\t\tthis -> n = n; z[1] = n;",
            "\t\tfor (int i = 0; i <= n; ++i) str[i] = s[i];",
            "\t\tfor (int i = 2, l = 0, r = 0; i <= n; ++i) {",
            "\t\t\tif (i <= r) z[i] = std::min(z[i - l + 1], r - i + 1);",
            "\t\t\twhile (i + z[i] <= n && s[i + z[i]] == s[z[i] + 1]) ++ z[i];",
            "\t\t\tif (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "\t\t} return;",
            "\t}",
            "\tpublic: auto Match(char *t, int m) -> void {",
            "\t\tfor (int i = 1, l = 0, r = 0; i <= m; ++i) {",
            "\t\t\tif (i <= r) p[i] = std::min(z[i - l + 1], r - i + 1);",
            "\t\t\twhile (i + p[i] <= m && t[i + p[i]] == str[p[i] + 1]) ++ p[i];",
            "\t\t\tif (i + p[i] - 1 > r) l = i, r = i + p[i] - 1;",
            "\t\t} return;",
            "\t}",
            "};"
		]
	},	
	"Template": {
		"prefix": "Template",
		"body": [
			"#include <bits/stdc++.h>",
			"namespace Switch {",
			"    #define function auto",
			"    #define boolean bool",
			"    #define FREOPEN // IO交互",
			"    #define MULTIPLE // 多组数据",
			"    #define DEBUG // 调试信息",
			"}",
			"function freopenI(std::string name) -> void {freopen((name + \".in\").c_str(), \"r\", stdin);}",
			"function freopenO(std::string name) -> void {freopen((name + \".out\").c_str(), \"w\", stdout);}",
			"using namespace Switch;",
			"namespace Codespace {",
			"    function Solver(int test_case = 0) -> void {",
			"        ",
			"    }",
			"}",
			"function main() -> decltype(0) {",
			"    std::string path = __FILE__;",
			"    std::string::size_type iPos = path.find_last_of('/') + 1;",
			"    std::string filename = path.substr(iPos, path.length() - iPos);",
			"    std::string realname = filename.substr(0, filename.rfind(\".\"));",
			"    boolean isfreopen = false;",
			"    #ifdef FREOPEN",
			"        isfreopen = true;",
			"    #endif",
			"    boolean ismultiple = false;",
			"    #ifdef MULTIPLE",
			"        ismultiple = true;",
			"    #endif",
			"    boolean isdebug = false;",
			"    #ifdef DEBUG",
			"        isdebug = true;",
			"    #endif",
			"    int T, Case = 0;",
			"    if (isfreopen) freopenI(realname), freopenO(realname);",
			"    if (ismultiple) scanf(\"%d\", &T); else T = 1;",
			"    while (T--) Codespace::Solver(++ Case);",
			"    return 0;",
			"}"
		]
	}
}